/** @file mm_axis3_fast_reduce.c


More details are yet to be documented!



*/

#include <stdlib.h>
#include <stdint.h>
#include "mat24_functions.h"
#include "mmgroup_generators.h"
#include "mm_op_fast.h"
#include "mm_op_fast_intern.h"
#include "mm_op_sub.h"   


//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c









/********************************************************************
*  Find G_x0 orbit und type-4 vector for reduction of axis
********************************************************************/

/**
   @brief Compute a type-4 vector in the Leech lattice for reducing an axis

   Let ``pa`` point to a structure of type ``mmv_fast_Amod3_type`` that
   contains data of a 2A axis  ``ax``. Such a structure may be obtained
   by calling function ``mm_axis3_fast_load``. Then the function
   computes the axis type ``t`` of the axis and a vector ``v4`` of type
   4 in the Leech lattice mod 2 that can be used for 'reducing' an axis.

   The standard case of the function is executed when parameter ``v2``
   is zero. Then the function returns ``(t << 25) + v4``. Here the
   vector ``v4`` is given in *Leech lattice encoding. Axis type ``t``
   is encoded as follows:

     | 2A | 2B | 4A | 4B | 4C | 6A | 6C | 8A | 6F | 10A | 10B | 12C |
     |----|----|----|----|----|----|----|----|----|-----|-----|-----|      
     |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 |  10 |  11 |  12 |

   The returned vector ``v4`` is a vector in the Leech lattice mod 2
   in *Leech lattice encoding*. Let ``g`` be any element of the
   subgroup \f$G_{x0}\f$ of the Monster the maps ``v4`` to the
   standard vector \f$\Omega\f$ of the Leech lattice mod 2. Then
   a transformation of axis ``ax`` by ``g``, and a subsequent
   transformation by a suitable power of the triality element in
   the Monster, maps axis ``ax`` to an axis of a simpler type. 
 
   The algorithm for finding ``v4`` is similar to that in [Sey22],
   Section 8.4; but it its considerably more involved for the
   following reasons:

     * Here the entries of axis ``ax`` are given mod 3, and
       not mod 15, as in [Sey22]

     * We want to obtain fewer reduction steps than in [Sey22].
       Therefore we analyze the two axes to be reduced
       simultaneously in some cases.

   The algorithm for reducing an element ``M`` of the Monster
   in [Sey22] considers the images of two fixed axes \f$v^+\f$
   and \f$v^-\f$. In the sequel we call the iamges of these two
   axes the *axis* and the *subaxis*, respectively.

   We first reduce the axis (ignoring the subaxis) by repeated calls
   to this function, until we arrive at an axis of axis type 2A. When
   this function detects an axis (or subaxis) of axis type 2A, it
   outputs the value ``t = 1``. In case ``t = 1`` the axis ``ax`` is
   in a one-to-one correspondence with a 2A involution ``q`` in the
   subgroup \f$Q_{x0}\f$ of \f$G_{x0}\f$. Then we output ``q`` as
   a 25-bit  vector in *Leech lattice encoding* instead of the
   vector ``v4``. In the following steps, it is much easier to deal
   with the 2A involution ``q`` in  \f$Q_{x0}\f$ than with the
   corresponding axis ``ax``.

   The structure referred by ``pa`` contains a pointer to a structure
   of type ``mmv_fast_matrix_type`` that usually contains both, an
   axis and a subaxis. When reducing an axis of axis type 2B, we may
   sometimes save a reduction step, when we also take the subaxis
   into account. This is done automatically if a subaxis has been 
   delared as present with funtion ``mm_axis3_fast_load_sub_row``. 
      
   This function may also be used to reduce a subaxis instead of an
   axis. If the argument ``v2`` is an element of the group \f$Q_{x0}\f
   of type 2 (instead of zero) then we consider axis ``ax`` as a
   subaxis (instead of an axis), and ``v2`` as the 2A involution
   corrresponding the the accompanying axis of the subaxis.

   In this case we perform a variant of the reduction procedure 
   in [Sey22],Section 9.2, which is similar to the procedure in
   ibid., Section 8.4. Then we return a value ``(t << 25) + v4``,
   with ``t`` and ``v4`` as described above. In case ``t = 1``, a
   type-2 vector ``q`` in \f$Q_{x0}\f$ is computed instead
   of ``v4``, as desrcibed above.

   If the input arguments do not satisfy the above requirements
   then the function may either fail and return a negarive value;
   or it may return a wrong result.
*/
// %%EXPORT p
int32_t mm_axis3_fast_find_v4(mmv_fast_Amod3_type *pa, uint32_t v2)
{
    int32_t status;
    switch (pa->norm) {
       case 0:
           status = mm_axis3_fast_echelon(pa, 2);
           if (status < 0) return -120;
            switch(pa->dim_img) {
               case 16:
                   return mm_axis3_fast_find_v4_case_4C(pa);
               default:
                   return -129;
           }
       case 1:
           status = mm_axis3_fast_echelon(pa, 0);
           if (status < 0) return -130;
           switch(pa->dim_img) {
               case 1:
                   return mm_axis3_fast_find_v4_case_2A_6A(pa);
               case 7:
                   return mm_axis3_fast_find_v4_case_4B(pa, v2);
               case 8:
                   return mm_axis3_fast_find_v4_case_12C(pa);
               case 22:
                   return mm_axis3_fast_find_v4_case_10A(pa, v2);
               default:
                   return -139;
           }
       case 2:
           status = mm_axis3_fast_echelon(pa, 1);
           switch(pa->dim_img) {
               case 24:
                   return mm_axis3_fast_find_v4_case_10B(pa);
               case 17:
                   return mm_axis3_fast_find_v4_case_6C(pa);
               case 16:
                   return mm_axis3_fast_find_v4_case_2B_6F(pa, v2);
               case 13:
                   return mm_axis3_fast_find_v4_case_8B(pa);
               case 1:
                   return mm_axis3_fast_find_v4_case_4A(pa);
               default:
                   return -149;
           }
       default:
           return -150;          
    } 
}



/********************************************************************
*  Low-level analysis of a G_x0 orbit
********************************************************************/

// %%EXPORT p
int32_t mm_axis3_fast_analyze_v4(mmv_fast_Amod3_type *pa, uint32_t v2, uint32_t *buf, uint32_t l_buf)
{
    int32_t status;
    switch (pa->norm) {
       case 0:
           status = mm_axis3_fast_echelon(pa, 2);
           if (status < 0) return -120;
            switch(pa->dim_img) {
               case 16:
                   return mm_axis3_fast_analyze_case_4C(pa, buf, l_buf);
               default:
                   return -139;
           }
       case 1:
           status = mm_axis3_fast_echelon(pa, 0);
           if (status < 0) return -130;
           switch(pa->dim_img) {
               case 1:
                   return mm_axis3_fast_analyze_case_6A(pa, buf, l_buf);
               case 7:
                   return mm_axis3_fast_analyze_case_4B(pa, v2, buf, l_buf);
               case 8:
                   return mm_axis3_fast_analyze_case_12C(pa, buf, l_buf);
               case 22:
                   return mm_axis3_fast_analyze_case_10A(pa, buf, l_buf);
               default:
                   return -139;
           }
       case 2:
           status = mm_axis3_fast_echelon(pa, 1);
           switch(pa->dim_img) {
               case 24:
                   return mm_axis3_fast_analyze_case_10B(pa, buf, l_buf);
               case 17:
                   return mm_axis3_fast_analyze_case_6C(pa, buf, l_buf);
               case 16:
                   return mm_axis3_fast_analyze_case_2B_6F(pa, v2, buf, l_buf);
               case 13:
                   return mm_axis3_fast_analyze_case_8B(pa, buf, l_buf);
               case 1:
                   return mm_axis3_fast_analyze_case_4A(pa, buf, l_buf);
               default:
                   return -149;
           }
       default:
           return -150;          
    } 
}




/**********************************************************************
* Number of nonzero entries in A**t, A**(t**2)
**********************************************************************/

/// @cond DO_NOT_DOCUMENT 

/**  
  @brief Count No of nonzero entries in part A transformed by triality

  Yet to be documented!!!
*/
// %%EXPORT p
int32_t mm_axis3_fast_num_entries_A_t(mmv_fast_matrix_type *pm, uint32_t row)
{
    if (pm == NULL || row >= 4 ||
            pm->p != 3 || pm->mode != 1) return -2;
    mmv_fast_type *padata = pm->p_v.p_vb[pm->current & 1];
    if (padata == NULL) return -2;
    uint32_t shift = 2 * row;
    uint32_t i;
    uint64_t u1, u2;

    // Zero diagonals of parts B and C
    uint8_t *pB = &(padata->r32[24].b[0]);
    for (i = 0; i < 24*32; i += 33)  pB[i] = pB[i + 24*32] = 0;
    
  #if GCC_VECTOR_ALIGNED >= 32
    mmv_fast_row32_type *p_row = &(padata->r32[24]);
    mmv_fast_row32_type ALIGNED(32) r1, r2, rtmp, rB, rC;
    memset(&r1, 0, sizeof(r1));
    memset(&r2, 0, sizeof(r2));
    for (i = 0; i < 24; ++i) {
        rB.v32[0] = (p_row[i].v32[0] >> shift) & 3; 
        rC.v32[0] = (p_row[i+24].v32[0] >> shift) & 3;
        rtmp.v32[0] = rB.v32[0] + rC.v32[0] + 1; 
        rtmp.v32[0] += rtmp.v32[0] >> 2;
        r1.v32[0] += rtmp.v32[0] & 2; 
        rtmp.v32[0] = rB.v32[0] + (rC.v32[0] ^ 3) + 1; 
        rtmp.v32[0] += rtmp.v32[0] >> 2;
        r2.v32[0] += rtmp.v32[0] & 2; 
    }
    u1 = r1.u64[0] + r1.u64[1] + r1.u64[2];
    u2 = r2.u64[0] + r2.u64[1] + r2.u64[2];
  #else
    uint64_t *pu = &(padata->r32[24].u64[0]), utmp, uB, uC;
    uint32_t j;
    u1 = u2 = 0;
    for (i = 0; i < 24; ++i) {
        for (j = 0; j < 3; ++j) {
           uB = (pu[j] >> shift) & 0x0303030303030303ULL;
           uC = (pu[j + 24*4] >> shift) & 0x0303030303030303ULL;
           utmp = uB + uC + 0x0101010101010101ULL;
           utmp += utmp >> 2;
           u1 += utmp & 0x0202020202020202ULL;
           utmp = uB + (uC ^ 0x0303030303030303ULL) + 0x0101010101010101ULL;
           utmp += utmp >> 2;
           u2 += utmp & 0x0202020202020202ULL;
        } 
        pu += 4; 
    }
  #endif
  u1 >>= 1;
  u1 = (u1 & 0x00ff00ff00ff00ffULL) + ((u1 >> 8) & 0x00ff00ff00ff00ffULL);
  u1 += u1 >> 16; u1 += u1 >> 32;
  u1 &=  0xffff;
  u2 >>= 1;
  u2 = (u2 & 0x00ff00ff00ff00ffULL) + ((u2 >> 8) & 0x00ff00ff00ff00ffULL);
  u2 += u2 >> 16; u2 += u2 >> 32;
  u2 &=  0xffff;
  return (int32_t)(((u2 >> 1) << 16) + (u1 >> 1));
}

/// @endcond 




/**
   @brief Compute exponent of triality element for reducing an axis

   Yet to be documented!!!

*/
// %%EXPORT p
int32_t mm_axis3_fast_find_exp_t(mmv_fast_matrix_type *pm, uint32_t row, uint32_t ax_type)
{
    uint32_t n1 = mm_axis3_fast_num_entries_A_t(pm, row);
    uint32_t n2 = n1 >> 16, i;
    n1 &= 0xffff;
    static int16_t n_expected[13] = {
      -1, 0, 28, 253,         147, 136, 231, 171,
      78, 8, 0x400, 0x401,    145
    };
    static uint8_t n_special[2][2] = {{181,1}, {164,36}};
    if (ax_type > 12) return -1;
    int32_t n = n_expected[ax_type];
    switch(n) {
        case -1:
        case 0:
           return n;
        case 0x400:
        case 0x401:
           goto special_case;
        default:
           if (n == n1) return 1;
           if (n == n2) return 2;
           return -2;
    }
special_case:
    n &= 1;
    for (i = 0; i < 2; ++i) {
        if (n_special[n][i] == n1) return 1;
        if (n_special[n][i] == n2) return 2;
    }
    return -3;      
}


#define err(loc, status) ((-100000 * (loc) + (status)) | 0x80000000UL)
   

/**
   @brief Compute exponent of triality element for reducing an axis

   Yet to be documented!!!

*/
// %%EXPORT p
int32_t mm_axis3_fast_reduce_axes(mmv_fast_matrix_type *pm, uint32_t *pg, uint32_t lg)
{
    uint32_t len = 0, round, last_type = 0xf, v2 = 0, v2a = 0, v4 = 0;
    int32_t status;
    mmv_fast_Amod3_type am3;
    if (lg > 256) lg = 256;
    for (round = 0; round < 5; ++round) { 
        uint32_t len1, ax_type, v4a, e1;
        status = mm_axis3_fast_load(pm, 0, &am3);
        if (status < 0) return err(11, status);
        status = mm_axis3_fast_load_sub_row(&am3, 1);
        if (status < 0) return err(12, status);
        status =  mm_axis3_fast_find_v4(&am3, 0);
        if (status < 0) return  err(12, status);
        ax_type = status >> 25;
        if (ax_type >= last_type) return -3711;
        last_type = ax_type;
        if (ax_type == 1) {
            v2 = status & 0x1ffffffUL;
            goto axis_found;
        }
        v4a = status & 0xffffffUL;
        if (len + 7 > lg) return -3712; 
        status = gen_leech2_reduce_type4(v4a, pg + len);
        if (status < 0) return err(13, status);
        len1 = status;
        status = mm_op_fast_word(pm, pg + len, len1, 1);
        if (status < 0) return err(14, status);
        len += len1;
        status = mm_axis3_fast_find_exp_t(pm, 0, ax_type);
        if (status < 0) return err(15, status);
        if (status < 1 || status > 2) return -3713;
        e1 = status;
        pg[len] = MMGROUP_ATOM_TAG_IT + 3 - e1;
        status = mm_op_fast_word(pm, pg + len, 1, 1);
        if (status < 0) return err(17, status);
        len += 1;
    }
    return -3714;

axis_found:
    last_type = 0xf;
    for (round = 0; round < 5; ++round) { 
        uint32_t len1, ax_type, v4a, e1;
        status = mm_axis3_fast_load(pm, 1, &am3);
        if (status < 0) return err(21, status);
        status =  mm_axis3_fast_find_v4(&am3, v2);
        if (status < 0) return err(22, status);
        ax_type = status >> 25;
        if (ax_type >= last_type) return 3811;
        last_type = ax_type;
        if (ax_type == 1) {
            v2a = status & 0x1ffffffUL;
            goto baby_axis_found;
        }
        v4a = status & 0xffffffUL;
        if (len + 7 > lg) return -3812; 
        status = gen_leech2_reduce_type4(v4a, pg + len);
        if (status < 0) return err(23, status);
        len1 = status;
        status = mm_op_fast_word(pm, pg + len, len1, 1);
        if (status < 0) return err(24, status);
        v2 =  gen_leech2_op_word(v2, pg + len, len1);
        len += len1;
        status = mm_axis3_fast_find_exp_t(pm, 1, ax_type);
        if (status < 0) return err(25, status);
        if (status < 1 || status > 2) return -3713;
        e1 = status;
        pg[len] = MMGROUP_ATOM_TAG_IT + 3 - e1;
        status = mm_op_fast_word(pm, pg + len, 1, 1);
        if (status < 0) return err(26, status);
        v2 =  gen_leech2_op_word(v2, pg + len, 1);
        len += 1; 
    }
    return -3814;

baby_axis_found:
    v4 = gen_leech2_mul(v2, v2a);
    if (v4 & 0xffffffUL) {
        status = gen_leech2_type(v4 & 0xffffffUL);
        if (status != 4) return err(30, -status);
        uint32_t len1, e1;
        if (len + 7 > lg) return -3912; 
        status = gen_leech2_reduce_type4(v4 & 0xffffffUL, pg + len);
        if (status < 0) return err(31, status);
        len1 = status;
        v4 =  gen_leech2_op_word(v4, pg + len, len1);
        len += len1;
        e1 = (v4 >> 24) & 1;
        pg[len] = MMGROUP_ATOM_TAG_IT + 2 - e1;
        v4 =  gen_leech2_op_word(v4, pg + len, 1);
        ++len;
    }
    if (v4 != 0x1000000UL) return -3913;
    return len;
}

#undef err


//  %%GEN h
/// @endcond 
//  %%GEN c

