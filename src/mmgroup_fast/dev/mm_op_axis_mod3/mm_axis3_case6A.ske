/** @file mm_axis3_case6A.c

Delas with axes of axis type 2A and 6A

*/

#include <stdlib.h>
#include <stdint.h>
#include "mat24_functions.h"
#include "mmgroup_generators.h"
#include "clifford12.h"
#include "mm_op_fast.h"
#include "mm_op_fast_intern.h"
#include "mm_op_sub.h"   


//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c






/**********************************************************************
* Transform fixed set of vectors in Leech lattice mod 2
**********************************************************************/

/**  
  @brief Transform a fixed set of vectors in the Leech lattice mod 2

  A fixed set ``S`` of vectors in the Leech lattice mod 2 is referred
  by the argument ``ps`` as described below. The function transforms
  that set of vectors by an element \f$g\f$ of the group \f$G_{x0}\f$
  and stores the set of transformed vectors in the array ``v`` of
  length ``lv`` in *Leech lattice encoding*.

  Here \f$g\f$ is given as a word of generators in the array ``g``
  of length ``lg``, with each atom of the word encoded as defined
  in the header file ``mmgroup_generators.h``.

  The structure ``ps`` refers to an array ``s``encoded as follows.

  Entry ``s[0]`` is the value ``0x100 * m + n``, with ``n <= 24``.
  Then the list ``s[1], ..., s[n]`` is a subset of ``S`` of vectors
  in *Leech lattice encoding*. Entry ``s[n+j+1]``, ``0 < j < m``
  is a bit array ``b[m-1], ..., b[0]`` such that the vector

  ``b[m-1] * s[m] + ... + b[0] * s[1]``

  is in the set ``S``. Thus ``S`` has size ``m + n``. The function
  returns the size of the set ``S``. It returns a negative value
  in case of error, e.g. if  ``lg < m + n``.
*/
// %%EXPORT px
int32_t mm_axis3_fast_transform_fix_leech2(uint32_t *ps, uint32_t *g, uint32_t lg, uint32_t *v, uint32_t lv)
{
    uint32_t n = ps[0] & 0xff, m = ps[0] >> 8, i, j, jmax, v2[48];
    int32_t status;
    if (n > 24 || lv < m + n) return -2;
    ++ps;
    for (i = 0; i < n; ++i) v[i] = ps[i];
    status = gen_leech2_op_word_leech2_many(v, n, g, lg, 0);
    if ((uint32_t)status != 0) return status < 0 ? status : -3;
    jmax = ((n + 1) >> 1) << 2;
    memset(v2, 0, sizeof(v2));
    for (j = 0; j < n; ++j) v2[(j << 1) + 1 - (j & 1)] = v[j];
    for (j = 0; j < jmax; j += 4) v2[j+3] = v2[j+1] ^ v2[j+2];
    v += n;
    ps += n;
    for (i = 0; i < m; ++i) {
        uint32_t b = *ps++, vc = 0;
        for (j = 0; j < jmax; j += 4) {
            vc ^= v2[j + (b & 3)];
            b >>= 2; 
        }
        *v++ = vc;      
    }
    return m + n;       
}



/**  
  @brief Prepare data for function mm_axis3_fast_transform_fix_leech2

  Given a list ``v`` of length ``lv`` of vectors in the Leech lattice
  mod 2 in **Leech lattice encoding**, the function computes a
  structure ``S`` encoding that set of these vectors. This structure
  is suitable for function ``mm_axis3_fast_transform_fix_leech2``
  and stored in the buffer ``ps``. Output buffer ``ps`` must have
  length ``lv + 1``. The order of the list ``v`` is not preserved.

  The function returns the length of the structure ``S`` in case of
  success and a negative value in case of error.
*/
// %%EXPORT px
int32_t mm_axis3_prep_fast_transform_fix_leech2(uint32_t *v, uint32_t lv, uint32_t *ps)
{
    uint64_t a[24];
    uint32_t nrows = 0, i, lv2 = 0;
    if (lv > 0xffff) return -2;
    for (i = 0; i < lv; ++i) {
        if (leech2matrix_add_eqn(a, nrows, 24, v[i])) 
            ps[++nrows] = v[i] & 0xffffff;
        else ps[lv - (lv2++)] = v[i] & 0xffffff; 
    }
    ps[0] = nrows + (lv2 << 8);
    ps += nrows + 1;
    for (i = 0; i < lv2; ++i) {
        int32_t x = leech2matrix_subspace_eqn(a, nrows, 24, ps[i]);
        if (x < 0) return -3;
        ps[i] = (uint32_t)x;
    }
    return lv2 + 1;
}





/**********************************************************************
* Number of nonzero entries in parts B and C
**********************************************************************/

/// @cond DO_NOT_DOCUMENT 

/**  
  @brief Count No of nonzero entries in parts B and C of a vector

  Let ``v`` be the main source vector from which the structure
  ``pa`` has been loaded. The function returns the sum of the
  number of nonzero entries in the parts 'B' and 'C' of the
  vector ``v``.
*/
// %%EXPORT p
int32_t mm_axis3_fast_num_entries_BC(mmv_fast_Amod3_type *pa)
{
    mmv_fast_type *padata = mm_axis3_fast_source_ptr(pa);
    if (pa->row_source < 0 || padata == NULL) return -2;
    uint32_t shift = 2 * pa->row_source;
    uint32_t i, result = 0;
    uint64_t u;

    // Zero diagonals of parts B and C
    uint8_t *pB = &(padata->r32[24].b[0]);
    for (i = 0; i < 24*32; i += 33)  pB[i] = pB[i + 24*32] = 0;
    
  #if GCC_VECTOR_ALIGNED >= 32
    mmv_fast_row32_type *pr32 = &(padata->r32[24]);
    mmv_fast_row32_type ALIGNED(32) row;
    memset(&row, 0, sizeof(row));
    for (i = 0; i < 48; ++i) {
        row.v32[0] += ((pr32[i].v32[0] >> shift) + 1) & 2; 
    }
    row.v32[0] >>= 1;
    u = row.u64[0] + row.u64[1] + row.u64[2];
  #else
    uint64_t *pu = &(padata->r32[24].u64[0]);
    u = 0;
    for (i = 0; i < 48; ++i) {
        // %%FOR* j in range(3)
        u += ((pu[%{j}] >> shift) ^ (pu[%{j}] >> (shift+1)))
              & 0x0101010101010101ULL;
        // %%END FOR
        pu += 4; 
    }
  #endif
  u = (u & 0x00ff00ff00ff00ffULL) + ((u >> 8) & 0x00ff00ff00ff00ffULL);
  u += u >> 16; u += u>>32;
  result = (uint32_t) (u & 0xffff);
  return result >> 1;
}

/// @endcond 


/**********************************************************************
* Load data into a structure of type mm_axis3_fast_load
**********************************************************************/


/// @cond DO_NOT_DOCUMENT 


/**  
  @brief Deal with axis type 2A and 6A
*/
static inline int64_t analyze_case_6A(mmv_fast_Amod3_type *pa)
{
    int32_t status;
    if (pa->p_source == NULL || pa->row_source < 0 || 
        pa->norm != 1 || pa->diag != 0) return -11;
    if (mm_axis3_fast_intersect(pa, 0) != 0) return -12;
    status = mm_axis3_fast_num_entries_BC(pa);
    if (status < 0) return status;
    if (status <= 1) return mm_axis3_fast_to_leech_mod3(pa, 24);
    if (status < 133) return -13000 - status;
        // 133 = min number of nonzero entries in the part BC
        // of the vector for a valid axis of type 6A

    uint64_t v3 = mm_axis3_fast_to_leech_mod3(pa, 24), v3_other;    
    uint32_t v2 = gen_leech3to2_short(v3), v2_other;
    if (v2 == 0) return -14;
    uint64_t subspace1[24], subspace2[24];
    uint32_t nrows = 0, i;

    nrows += leech2matrix_add_eqn(subspace1, nrows, 24, v2);
    v2 += 0x2000000;
    for (i = 0; i < 10000; ++i) { 
        uint32_t v_new = mm_axis3_fast_rand_short_nonzero(pa, v2);  
        nrows += leech2matrix_add_eqn(subspace1, nrows, 24, v_new);
        if (nrows == 9) v2 &= 0xffffff;
        if (nrows == 22) goto compute_v3;
    }
    return -15;

compute_v3:
    leech2matrix_echelon_eqn(subspace1, nrows, 24, subspace2);  
    status = leech2_matrix_orthogonal(subspace2, subspace1, nrows);
    if (status != 22) return -21;
    v2_other = subspace1[22];
    if (v2_other == v2) v2_other = subspace1[23];
    v3_other = gen_leech2to3_short(v2_other);
    if (v3_other == 0) return -16;

    for (i = 0; i <2; ++i) {
        v3_other = gen_leech3_add(v3, v3_other);
        uint64_t w = mat24_bw24(v3_other ^ (v3_other >> 24));
        if (w % 3 == 0) return (w << 48) + v3_other;
    }
    return -17;
}

/// @endcond 



/**********************************************************************
* Tables for dealing with case 6A
**********************************************************************/

/// @cond DO_NOT_DOCUMENT 

typedef struct  {
    uint8_t  weight;      // key for structure: weight of support of v3
    uint8_t  len_img_p;   // length of image of permutation p
    uint8_t  start_img_p; // start of image of permutation p
    uint8_t  len_op_y;    // length of y operation table
    uint8_t  start_op_y;  // start of y operation table
    uint8_t  start_v4;    // start of encoded list of type-4 vectors
    uint64_t v3_ref;      // expected value of v3 after applying p and y
} info_6A_type;


static info_6A_type T6A[6] =  {
    // %%TABLE MM_AXIS3_CASE6A_INFO_6A
};

#define LEN_T6A (sizeof(T6A) / sizeof(info_6A_type))

static uint8_t A_IMG_P[] = { // array of concatenated images of perm. p 
    // %%TABLE MM_AXIS3_CASE6A_A_IMG_P
};

static uint32_t A_OP_Y[] = { // array of concatenated y operations 
    // %%TABLE MM_AXIS3_CASE6A_A_OP_Y, uint32
};

static uint32_t A_V4[] = { // array of encoded type-4 vectors 
    // %%TABLE MM_AXIS3_CASE6A_A_V4, uint32
};

/// @endcond 


/**********************************************************************
* Dealing with case 6A
**********************************************************************/

/// @cond DO_NOT_DOCUMENT 

/**  
  @brief Reduce vector for Axis type 6A to representative of N_x0 orbit

  The part \f$300_x\f$ of an axis of type 6A can be described by a
  vector in the Leech lattice mod 3 of type \f$6_{22}\f$. See
  Section *C interface for file gen_leech_reduce_mod3.c* in the
  mmgroup documentation for the definition of type \f$6_{22}\f$.

  Let ``v3`` be such a vector in *Leech lattice mod 3 encoding*. The
  function computes a \f$g \in N_{x0}\f$ such that transformation
  with \f$g\f$ maps ``v3`` to the representative of its orbit
  under \f$N_{x0}\f$. That orbit is uniquely determined by the
  weight of ``v3``.

  The function also compute a list ``l4`` of type-4 vectors in the
  Leech lattice mod 2 (in *Leech lattice encoding*) such that an
  element of \f$G_{x0}\f$ mapping any entry of list ``l4`` to the
  standard type-4 vector \f$\Omega\f$ also maps the input axis to a
  'nice' axis. Here an axis is 'nice' if a power of the triality
  element \f$\tau\f$ maps that axis to an axis of type 4A, so that
  the reduction process for axes described in [Seysen22] is possible.

  Altogether, there are 891 possible candidates for entries of the
  list ``l4``.  The function returns a list of such entries leading
  to 'best' possible words of atoms of  \f$G_{x0}\f$. The definition
  of such a 'best' does not depend on the implementation of this
  function. 

  Output buffer ``g`` must have size at least 3 + 77.

  The function returns \f$g\f$ in buffer ``g`` as a zero-padded word
  of generators of the Monster of length 3 in buffer``g[0:3]``.  It
  returns the list ``l4`` of length ``n`` in buffer ``g[3:n+3]``.

  In case of success the function returns the length ``n`` of the
  list ``l4``.  A negative return value indicates an error.
*/
// %%EXPORT px
int32_t mm_axis3_fast_map_Case6A(uint64_t v3, uint32_t *g)
{
    uint32_t len_g = 0;
    g[0] = g[1] = g[2] = 0;
    #define mul_atom(atom) \
        v3 = gen_leech3_op_vector_atom(v3, atom); \
        g[len_g++] = atom
    #define mul_y_atom(y) \
        mul_atom(MMGROUP_ATOM_TAG_Y + mat24_vect_to_gcode(y))

    // Compute the support ``supp`` of ``v3``, its weight ``w``,
    // and a list synromes ``synd[0],...,synd[n_synd-1]`` of it.
    // Here  ``supp`` and  ``synd[i]`` are bit vectors; and
    // ``n_synd`` is 1 or 6.
    uint32_t supp = (uint32_t)((v3 ^ (v3 >> 24)) & 0xffffff);
    uint32_t w = mat24_bw24(supp);
    uint32_t synd[6];
    uint32_t n_synd = mat24_all_syndromes(supp, synd);
    // Compute a Golay code word ``y`` such that transfroming
    // ``v3`` with that cod wird minimizes the weight of the
    // negative entries of ``v3``. Then transform ``v3``.
    uint32_t neg = (uint32_t)(~v3 & (v3 >> 24) & 0xffffff);
    uint32_t zerobit = mat24_lsbit24(~supp & 0xffffff);
    zerobit -= (zerobit == 24);
    uint32_t y = mat24_syndrome(neg, zerobit) ^ neg;
    mul_y_atom(y);

    // Compute a permutation in M_24 for transforming the support
    // of ``v3`` to a standard bit vector, depending on the
    // weight ``w``. We first compute a list ``blist`` of entries
    // to be tansformed to a fixed list ``img`` by a permutation
    // in M_24.  Later we will read the list ``img`` and its
    // from a table.
    uint8_t blist[24], img[7], len_img, pi[24];
    uint32_t syn, i, l, octad;
    switch (w) {
        case 24:
            neg = ~v3 & (v3 >> 24) & 0xffffff;
            syn = mat24_syndrome(neg, 0); 
            mat24_vect_to_bit_list(syn, blist); 
            break;
        case 18:
            supp ^= 0xffffff;
        case 6:
        case 3:
            mat24_vect_to_bit_list(supp, blist); 
            break;
        case 12:
            l=0;
            for (i = 0; i < n_synd; ++i) {
                if ((synd[i] & supp) == synd[i]) {
                    if (l == 0) {
                        mat24_vect_to_bit_list(synd[i], blist);
                        l = 4;
                    } else {
                        blist[l++] = mat24_lsbit24(synd[i]);
                    }
                }
            }
            break;
        case 15:
            octad = supp ^ synd[0] ^ 0xffffff;
            mat24_vect_to_bit_list(octad, blist);
            blist[6] = mat24_lsbit24(synd[0]);
            break;
        default:
            return -12;
    }
    
    // List ``blist`` has been computed. Store pointer to table entry
    // for weight ``w`` in ``pT``. In case of success, goto pT_found. 
    info_6A_type *pT;
    for (i = 0; i < LEN_T6A ; ++i) {
        pT = T6A + i;
        if (pT->weight == w) goto pT_found;
    }
    return -13;
   
pT_found:
    // Read image ``img`` and its length from the Table. Then use
    // function ``mat24_perm_from_map`` to find a permutation ``pi``
    // in M_24 mapping ``blist`` to ``img``.
    // Transfrom ``v3`` with``pi``.
    len_img = pT->len_img_p;
    memcpy(img, A_IMG_P + pT->start_img_p, len_img * sizeof(int8_t));
    int32_t status =  mat24_perm_from_map(blist, img, len_img, pi);
    if (status < 1) return status < 0 ? status : -14;
    uint32_t p_num = mat24_perm_to_m24num(pi);
    mul_atom(MMGROUP_ATOM_TAG_P + p_num);

    // Store bitmap of negative entries of ``v3`` in ``neg``. Then
    // read a list of pairs ``(b, y)`` from the table. If bit ``b``
    // is set in ``neg`` the transfrom ``v3`` with the Golay code
    // word ``y``. We output the accumulated transformation. 
    neg = ~v3 & (v3 >> 24) & 0xffffff;
    y = 0;
    uint32_t *pY = A_OP_Y +  pT->start_op_y;
    for (i = 0; i < pT->len_op_y; ++i) {
        uint32_t m = pY[i];
        if ((1 << (m >> 24)) & neg) {
            y ^= m; neg ^= m;
        }
    }
    mul_y_atom(y & 0xffffff);
    // Check that the final transformed vector ``v3`` equals
    // the reference value stoted in the table. 
    if (v3 != pT->v3_ref) return -15;

    #undef mul_y_atom
    #undef mul_atom

    // Remaining stuff is yet to be documented!!
    #define T4_BUFSIZE 77
    uint32_t *buf = g+3, len_buf;
    mm_group_invert_word(g, len_g);
    len_buf = status = mm_axis3_fast_transform_fix_leech2(
        A_V4 + pT->start_v4, g, len_g, buf, T4_BUFSIZE);
    if (status < 0) return status;
    #undef T4_BUFSIZE
    return len_buf;
}




/// @endcond 

/**********************************************************************
* intermediate function for testing
**********************************************************************/

/**  
  @brief Yet to be documented!!!!!
*/
// %%EXPORT p
int32_t mm_axis3_fast_analyze_case_6A(mmv_fast_Amod3_type *pa, uint32_t *buf, uint32_t l_buf)
{
    int64_t v3 = analyze_case_6A(pa);
    if (v3 < 0) return v3;
    if (v3 >> 48) {
        if (l_buf < 4) return -3;
        buf[0] = 6; buf[1] = (uint32_t)(v3 >> 48);
        buf[2] = (uint32_t)(v3 & 0xffffff);
        buf[3] = (uint32_t)((v3 >> 24) & 0xffffff);
        return 4;
    } else {
        if (l_buf < 2) return -3;
        buf[0] = 2;
        buf[1] = gen_leech3to2(v3);
        return 2;
    }
}




/**********************************************************************
* The final exported function of this module
**********************************************************************/

/// @cond DO_NOT_DOCUMENT 



static inline int32_t get_type_2A(mmv_fast_Amod3_type *pa, uint64_t v3)
{
    mmv_fast_type *padata = mm_axis3_fast_source_ptr(pa);
    if (pa->row_source < 0 || padata == NULL) return -2;
    uint32_t shift = 2 * pa->row_source;
    int32_t v2 = gen_leech3to2_short(v3);
    if (v2 < 0) return v2;
    if (v2 >= 0x1000000) return -3;
    uint32_t index =  mm_aux_index_leech2_to_sparse(v2); 
    if (index == 0) return -4;  
    int32_t iindex = mm_aux_index_sparse_to_intern(index);
    if (iindex < 0) return -5;
    uint32_t value = (padata->b[iindex] >> shift) & 3;
    if ((value + 3) & 2) return -6;
    return v2 + ((value >> 1) << 24);
}


static inline int32_t get_type_2A_reduce_v4(uint32_t v2found)
{
    uint32_t gcode, cocode, syn, b, o, res;
    // GREY_OCTADS[6] is an grey octad in gcode notation contaning
    // entries 0,1,2,3, and 4*i, 4*i+1, 4*i+2,4*i+3.
    // For any such octad o we have theta(o= = 0.
    static uint16_t GRAY_OCTADS[6] = {
        0x80f, 0x80f, 0x801, 0x802, 0x804, 0x808 
    };
    switch(gen_leech2_subtype(v2found)) {
        case 0x20:
            return v2found;
        case 0x21:
            gcode = (v2found >> 12) & 0xfff;
            cocode = (mat24_ploop_theta(gcode) ^ v2found) & 0xffffff;
            syn = mat24_cocode_syndrome(cocode, 0);
            if (syn == 0 || syn & (syn - 1)) return -301;
            b = mat24_lsbit24(syn);
            o = GRAY_OCTADS[b >> 2];
            cocode = mat24_ploop_cap(gcode, o);
            res = (o << 12);
            res ^= (mat24_ploop_theta(o) ^ cocode) & 0xfff;
            if (gen_leech2_type(res) != 4) res ^= 0x800000;
            return (1UL << 25) + res;
        case 0x22:
            gcode = (v2found >> 12) & 0xfff;
            o = mat24_gcode_to_octad(gcode, 0);
            res = mat24_suboctad_to_cocode(7, o);
            if (gen_leech2_type(res ^ v2found) != 2) res ^= 0x800000;
            return (1UL << 25) + res;
        default:
            return -302;

    }
}


static inline int32_t get_type_2A_reduce_v4_baby(
    uint32_t v2found, uint32_t v2_main)
{
    uint32_t v4 = (v2found ^ v2_main) & 0xffffff;
    if (gen_leech2_type(v4) == 4) return  (1UL << 25) + v4;
    if (v4 == 0) return v2found ^ v2_main;
    return -304;         
}



/**  
  @brief Yet to be documented!!!!!
*/
// %%EXPORT px
int32_t mm_axis3_fast_find_case_2A(uint32_t v2, uint32_t v2_main)
{
    if (v2_main == 0) return get_type_2A_reduce_v4(v2);
    else return get_type_2A_reduce_v4_baby(v2, v2_main);
}



/// @endcond 


/**********************************************************************
* The final exported function of this module
**********************************************************************/



/// @cond DO_NOT_DOCUMENT 



/**  
  @brief Yet to be documented!!!!!
*/
// %%EXPORT p
int32_t mm_axis3_fast_find_v4_case_2A_6A(mmv_fast_Amod3_type *pa)
{
    int64_t status64 = analyze_case_6A(pa);
    uint64_t v3 = status64;
    if (status64 < 0) return (int32_t)(status64 | 0x80000000);
    if (v3 >> 48) {
        uint32_t g[3+77], mu = 0x1000000;
        int32_t status = mm_axis3_fast_map_Case6A(v3, g), i;
        if (status < 0) return status;
        for (i = 0; i < status; ++i) if (g[3+i] < mu) mu = g[3+i];
        return mu < 0x1000000 ? ((6UL << 25) + mu) : -21;
    } else {
        return (1UL << 25) +  get_type_2A(pa, v3);
    }
}



/// @endcond 




/**********************************************************************
* Deprecated stuff
**********************************************************************/



/// @cond DO_NOT_DOCUMENT 


/**  
  @brief Return short Leech lattice vector with nonzero entry

  If a source vector in the Griess algebra is stored in the
  structure ``pa`` of type ``mmv_fast_Amod3_type`` then we return
  a random vector ``v`` of the Leech lattice modulo 2 such that
  the corresponding entry in the source vector in nonzero (mod 3).
  Parameter ``scalar`` is interpreted as follows:

  Bits 23...0: a vector ``w`` in the  Leech lattice modulo 2

  Bit 24: an element ``k`` of ``GF(2)``

  Bit 25: an boolan value ``small``

  Then we return only vectors ``v`` such that the scalar
  product ``<v, w>`` is equal to ``k``.

  If  ``small`` is set then we always return a vector in the Leech
  lattice modulo 2 corresponding to a Golay cocode vector (plus
  possibly the standard frame \f$\Omega\f$) instead.
    
  The function returns a negative value in case of failure. 

  This function has not yet been tested!!! 
*/
/* Deprecated!!!!!!!!!!!!!!
// %%EXPORT p
int32_t mm_axis3_fast_rand_short_nonzero_old(mmv_fast_Amod3_type *pa, uint32_t scalar)
{
    uint64_t rnd64, prod;
    uint32_t ext, intern, entry, v, n = 1000000, i, j, c;
    uint32_t k = (scalar >> 24) & 1;
    uint32_t small = (scalar >> 25) & 1;
    scalar =  ((scalar >> 12) & 0xfff) + ((scalar & 0xfff) << 12);
    mmv_fast_type *padata = mm_axis3_fast_source_ptr(pa);
    if (pa->row_source < 0 || padata == NULL) return -2;
    do {
        rnd64 = pcg32_next(pa);
        if (small) {
            rnd64 *= 24;
            i = (uint32_t)(rnd64 >> 32);
            rnd64 = (rnd64 & 0xffffffffULL) * 24;
            j = (uint32_t)(rnd64 >> 32);
            if (i == j) continue;
            c = (uint32_t)(rnd64 >> 31) & 1;
            intern = ((24 + 24*c + i) << 5) + j;
            entry = ((uint8_t*)padata)[intern] >> (2 * pa->row_source);
            if ((entry + 3) & 2) continue;
            v = mat24_vect_to_cocode((1 << i) ^ (1 << j)) | (c << 23);
        } else {
            ext = (uint32_t)((rnd64 * 98280) >> 32) + 300;
            intern = mm_aux_index_extern_to_intern(ext);
            if (intern & 0xff000000UL) continue;
            entry = ((uint8_t*)padata)[intern] >> (2 * pa->row_source);
            if ((entry + 3) & 2) continue;
            v = mm_aux_index_intern_to_leech2(intern);
            if (v == 0) continue;
        }
        scalprod(v, scalar, prod);
        if  (prod != k) continue;
        return v;
    } while (--n); // we dont't want an endless loop
    return -1;

}
*/

/// @endcond 



/**********************************************************************
* end of C functions
**********************************************************************/



//  %%GEN h
/// @endcond 
//  %%GEN c

