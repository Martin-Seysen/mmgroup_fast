#define MM_OP_FAST_ALLOC
#include "mm_op_fast.h"
#include "mm_op_sub.h"   


//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c



/** 
  @brief Return pointer to data of structure of type mmv_fast_matrix_type

  Return a pointer to the data bytes in a structure of 
  type ``mmv_fast_matrix_type`` referred by ``pm`` if ``pm->mode``
  is equal to 1, and data are present. Return NULL otherwise.
*/
static uint8_t* ptr_data_mode1(mmv_fast_matrix_type *pm)
{
     if (pm == NULL) return NULL;
     if (pm->mode == 1) {
         mmv_fast_type **p_buf = pm->p_v.p_vb;
         mmv_fast_type *p_data = p_buf[pm->current & 1];
         if (p_data == NULL) return NULL;
         return p_data->b; 
     } 
     return NULL;
}

/** 
  @brief Store data to a structure of type mmv_fast_matrix_type

  The function stores data to a structure ``a`` of
  type ``mmv_fast_matrix_type`` referred by ``pa``. The data to be
  stored are given by the array ``data`` of length ``len``.

  Each entry ``x`` of that array describes an column in the 
  structure ``a`` to  be modified. Bits 31,...,8 of an entry contain
  the index ``j`` of the column to be modified in 'sparse'
  representation. Bits 7,...,0 contain the data to be stored at this
  entry. We store the value ``(x >> (2 * k)) & 3`` in row ``k``
  and column ``j`` of the structure ``a`` for ``0 <= k < 4``. 

  Illegal indices are ignored. The function performs no action
  if ``a->mode != 1``, or if no data are allocated for ``a``.

  The function returns 0 if all data have been stored successfully
  and -1 otherwise. The function fails if ``a->mode != 1``.
*/
// %%EXPORT p
int32_t mm_op_fast_mode1_put(mmv_fast_matrix_type *pm, uint32_t *data, uint32_t len)
{
    uint32_t i;
    int32_t v1, v2, status = 0;
    uint8_t *pb = ptr_data_mode1(pm), b;
    if (pb == NULL) return -1;
    for (i = 0; i < len; ++i) {
        v1 = mm_aux_index_sparse_to_intern(data[i] & 0xffffff00UL);
        if (v1 >= 0) {
            b = (uint8_t)(data[i] & 0xff); 
            pb[v1] = b;
            v2 = mm_aux_index_check_intern(v1);
            if (v2 > 0) pb[v2] = b;
        } else status = -1;
    }
    return status;
}


/** 
  @brief Load data from structure of type mmv_fast_matrix_type

  The function loads data from a structure ``a`` of
  type ``mmv_fast_matrix_type`` referred by ``pa``. The data are
  stored to an array ``data`` of length ``len``.

  Each entry ``x`` of array ``data`` describes a column in the 
  structure ``a`` to  be loaded. Bits 31,...,8 of an entry contain
  the index ``j`` of the column to be loaded in 'sparse'
  representation. Bits 7,...,0 of entry ``data`` are modified so
  that will contain the data read frm the array. We store the
  value of row ``j`` and column ``k``  the structure ``a`` in the
  bits ``(2*i+1, 2*i)`` of that entry for ``0 <= k < 4``. These
  stored values are reduced modulo 3.

  Bit 7,...,0  of an entry of array ``data`` are set to zero if the
  corresponding entries of ``a``are not present.
  
  .
  The function returns 0 if all data have been loaded successfully
  and -1 otherwise. The function fails if ``a->mode != 1``.
*/
// %%EXPORT p
int32_t mm_op_fast_mode1_get(mmv_fast_matrix_type *pm, uint32_t *data, uint32_t len)
{
    uint32_t i;
    int32_t v1, status = 0;
    uint8_t *pb = ptr_data_mode1(pm), b, tmp;
    if (pb == NULL) {
        for (i = 0; i < len; ++len) data[i] |= 0xffUL; 
        return -1;
    }
    for (i = 0; i < len; ++i) {
        data[i] &= 0xffffff00UL;  
        v1 = mm_aux_index_sparse_to_intern(data[i]);
        if (v1 >= 0) {
            b = pb[v1];
            tmp = (b ^ (b >> 1)) & 0x55;
            b ^= tmp ^ (tmp << 1);
            data[i] |= b;
        }
        else {
            status = -1;
            data[i] |= 0xffUL; 
        }
    }
    return status;
}


/** 
  @brief Store zero to structure of type mmv_fast_matrix_type

  The function stores zero to a structure ``a`` of
  type ``mmv_fast_matrix_type`` referred by ``pa``. It performs
  no action if ``a->mode != 1``.
*/
// %%EXPORT p
void mm_op_fast_mode1_zero(mmv_fast_matrix_type *pm)
{
    if (pm->mode == 1) {
        mmv_fast_type **p_buf = pm->p_v.p_vb;
        v32_8_type *v32 = (p_buf[pm->current & 1])->v32;
        memset(v32, 0, MM_FAST_BYTELENGTH * sizeof(uint8_t)); 
    } 
}


/** 
  @brief An extremely dangerous low-level function!

  Not for public use!!!!
*/
// %%EXPORT p
void mm_op_fast_mode1_poke(mmv_fast_matrix_type *pm, uint32_t index, uint32_t value)
{
    uint8_t *pb = ptr_data_mode1(pm);
    if (pb == NULL) return;
    if (index >= MM_FAST_BYTELENGTH) return;
    pb[index] = (uint8_t)(value & 0xff);
}





//  %%GEN h
/// @endcond 
//  %%GEN c

