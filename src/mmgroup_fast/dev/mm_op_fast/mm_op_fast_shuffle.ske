#define MM_OP_FAST_PERMUTATIONS
#include "mm_op_fast.h"
#include "mat24_functions.h"


//  %%GEN h
/// @cond DO_NOT_DOCUMENT 
//  %%GEN c


/****************************************************************************
** Prepare 24-bit shuffling
****************************************************************************/


static inline int32_t _perm_to_shuffle16(uint8_t *pi, uint8_t *pi_out)
{
    uint_fast32_t j, i0 = 0, i1 = 15;
    uint8_t tmp;

    for (j = 0; j < 24; ++j) {
        pi_out[j] = j;
        if (pi[j] >= 24) return -11;
    }
    while (i0 < 8) {
        if (pi[i0] >= 16) {
            while (pi[i1] >= 16) {
                i1 -= 1;
                if (i1 < 7) return -12;
            }
            tmp = pi_out[i0];  pi_out[i0] = pi_out[i1]; pi_out[i1] = tmp;
            i1 -= 1;
        }
        i0 += 1;
        if (i1 < 7) return -13;
    }
    return 0; 
}   



static inline int32_t _perm_to_xch_big(uint8_t *pi, uint8_t *pi_out)
{
    uint_fast32_t i, j, ok = 0, rounds = 16;
    uint8_t tmp, pi1[32];


    for (i = 0; i < 24; ++i) {
        pi_out[i] = i;
        pi1[i] = pi[i];
        if (pi[i] >= 24) return -21;
    }
    while (!ok) {
        for (i = 0; i < 16; ++i) {
            if (pi1[i] >= 16) {
                j = pi1[i] - 16;
                tmp = pi1[i], pi1[i] = pi1[j];  pi1[j] = tmp;
                tmp = pi_out[i], pi_out[i] = pi_out[j];  pi_out[j] = tmp;
            }
        }
        ok = 1;
        for (i = 0; i < 8; ++i)  ok &= (pi1[i] == (i + 16));
        if (--rounds == 0) return -22; // never ever an endless loop!
    }
    return 0; 
}



// %%EXPORT
int32_t mm_op_fast_prep_shuffle24(uint8_t *pi, mmv_fast_shuffle24_type *out)
{
  #if MM_OP_FAST_SPLIT_SHUFFLE24 == 1
    uint8_t pi0[32], pi1[32], pi2[32], pi_strip[32], i;
    int32_t res;
    static uint8_t _pi_fix[32] = {
       16,17,18,19,20,21,22,23, 8,9,10,11,12,13,14,15, 0,1,2,3,4,5,6,7
    };
    if ((res =_perm_to_shuffle16(pi, pi0)) < 0) return res;
    mat24_mul_perm(pi0, pi, pi_strip);
    mat24_mul_perm(_pi_fix, pi_strip, pi_strip);
    if ((res =_perm_to_xch_big(pi_strip, pi1)) < 0) return res;
    mat24_mul_perm(pi1, pi_strip, pi_strip);
    mat24_mul_perm(_pi_fix, pi_strip, pi_strip);
    mat24_inv_perm(pi_strip, pi2);
    memcpy(out->b, pi0, 16);
    memcpy(out->b + 32, pi1, 16);
    memcpy(out->b + 64, pi2, 16);
    for (i = 16; i < 32; ++i) {
       out->b[i + 64] = out->b[i + 32] = out->b[i] = i;
    } 
    return 1;
  #else
    #if MM_OP_FAST_SPLIT_SHUFFLE24 == 0
      uint8_t i;
      uint8_t inv_pi[32];
      mat24_inv_perm(pi, inv_pi);
      memcpy(out->b, inv_pi, 24);
      for (i = 24; i < 32; ++i) out->b[i] = i;
      #ifdef SHUFFLE64
         for (i = 0; i < 32; ++i) out->b[i + 32] = out->b[i] + 32;
      #endif
      return 0;
    #else
      return -1;
    #endif
  #endif
}





// %%EXPORT px
int32_t mmgroup_fast_test_prep_shuffle24(uint8_t *pi, uint8_t *mask)
{
     mmv_fast_shuffle24_type imask;
     int32_t res;
     res = mm_op_fast_prep_shuffle24(pi, &imask);
     memcpy(mask, &imask, 96);
     return res;      
}


// %%EXPORT px
void mmgroup_fast_test_shuffle24(uint8_t *data, uint8_t *mask)
{
     mmv_fast_shuffle24_type imask;
     mmv_fast_row32_type idata;
     memcpy(&idata, data, 24);
     memcpy(&imask, mask, 96);
     _shuffle24(idata, imask, 0, &idata);
     memcpy(data, &idata, 24);
}





// %%EXPORT px
void mmgroup_fast_test_shuffle64(uint8_t *data, uint8_t *mask, uint8_t *out)
{
    mmv_fast_row64_type *p_align64 = alloca_aligned(2*64, 64);
    memcpy(p_align64, data, 64);
    memcpy(p_align64 + 1, mask, 64);
    _shuffle64(p_align64[0], p_align64[1], p_align64);
    memcpy(out, p_align64, 64);
}





//  %%GEN h
/// @endcond 
//  %%GEN c

