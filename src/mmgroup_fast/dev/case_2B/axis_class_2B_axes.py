import sys
import time
import os
import glob
from math import floor
from random import randint, shuffle, sample
from collections import defaultdict
from multiprocessing import Pool
import argparse


import numpy as np


from mmgroup.bitfunctions import lin_table, bit_mat_inverse, bit_mat_mul
from mmgroup.generators import gen_leech2_type
from mmgroup.generators import gen_leech2_reduce_type4
from mmgroup.generators import gen_ufind_init, gen_ufind_union
from mmgroup.generators import gen_ufind_find_all_min, gen_ufind_make_map
from mmgroup.generators import gen_leech2_op_word_many 
from mmgroup.mm_op import mm_op_eval_A, mm_aux_get_mmv_leech2
from mmgroup.mm_reduce import mm_reduce_analyze_2A_axis
from mmgroup.mm_reduce import mm_reduce_op_2A_axis_type
from mmgroup import MM, AutPL, PLoop, Cocode, XLeech2, Xsp2_Co1, MMV, GcVector
from mmgroup.axes import Axis, BabyAxis
from mmgroup.tests.axes.get_sample_axes import next_generation_pool


######  Defining the relevant axis Y ####################################


# Y is the standard 2A involution such that x_{-1} * y is in class 2B
# We have Y = y_o, where o is the standard octad.
Y = MM('y', PLoop(range(8)))
# Y_Gx0 is Y as an element of G_x0
Y_Gx0 = Xsp2_Co1(Y)
# AXIS_Y is the axis of involution Y
AXIS_Y = Axis('i', Y)


# CONJ_Y conjugates AXIS_Y to the standard axis v^+
CONJ_Y = Y.conjugate_involution()[1]
# CONJ_Y_INV conjugates the standard axis v^+ to AXIS_Y 
CONJ_Y_INV = CONJ_Y ** -1
assert Axis() * CONJ_Y_INV == AXIS_Y
NEG_AXIS = Axis(BabyAxis()) * CONJ_Y ** CONJ_Y_INV
NEG_AXIS.rebase()

######  Generate random elements fixing the axis AXIS_Y #################



def rand_y(*_):
    """Return a random element in G_x0 fixing axis AXIS_Y

    The function returns the random element as an instance
    of class MM.
    """
    g = Xsp2_Co1('r')
    i8 = Y_Gx0 ** g
    c, h = i8.conjugate_involution_G_x0()
    #assert c == "2A_o+"
    g1 = g*h
    #assert  Y_Gx0 ** g1 == Y_Gx0, ( (Y_Gx0**g1),  Y_Gx0)
    return MM(g1)


TY = MM('d', Cocode([8])) ** (MM('t', 1))


def rand_ty():
    """Return an element in a certain group fixing axis AXIS_Y

    Let H_2 be elementray abelian 2-group of order 2^8 generated by

    x_-1, x_Omega, x_s, x_o, and y_o,

    where o is the standard octad as above, and s stands for the
    set of all elements of the Golay cocode that are suboctads of
    octad o. Note that AXIS_Y is the axis of y_o. 

    Let H be the subgroup of the centralizer of AXIS_Y that
    centralizes also H_2. H is of structure 2^9.2^15.S_8(2).

    The function returns an element of H that is not in G_x0.
    Note that H \cap G_x0 is a maximal subgroup of H. The
    returned element is in G_x0 \tau g_x0, where \tau is 
    the triality element in N_0.

    The returned element is 'close to random'.
    """
    g1 = rand_y() * TY * rand_y()
    #assert  AXIS_Y * g1 == AXIS_Y #, ((Y_Gx0*g1),  Y_Gx0)
    return g1

PI = MM('p', zip(list(range(8)) + [9], list(range(8)) + [10]))
c, H_PI = PI.conjugate_involution_G_x0()
assert c == "2A_o+", c
TAU1 = MM('t', 1) ** H_PI
assert Y ** TAU1 == Y


def rand_out():
    """Return random a element in a certain group fixing axis AXIS_Y

    Let C be the centralizer of AXIS_Y and H be the subgroup of C
    defined in function rand_ty().

    The function returns an element of C that is not in H.
    Note that H is a maximal subgroup of C. The
    returned element is in G_x0 \tau g_x0, where \tau is 
    the triality element in N_0.

    The returned element is 'close to random' in the set specified.   
    """
    #assert  Y_Gx0 ** g1 == Y_Gx0, ( (Y_Gx0**g1),  Y_Gx0)
    return rand_y() * TAU1 ** randint(1, 2) * rand_y()




###### Short vectors in Leech lattice mod 2 related to Y #########



_SHORT_E8_VECTORS = None

def short_E8_vectors():
    """Basis and short vectors in Leech lattice mod 2 related to Y

    There are 256 elements of the Leech lattice mod 2 related to
    involution Y in a standard way, with 120 elements being short,
    (i.e. of type 2); as described in function prep_analyse_axis().

    The function returns a pair (leech_basis, short_list). Here
    leech_basis is a basis of the linear space containing these
    256 elements of the Leech lattice mod 2.

    short_list is a list enumerating the 120 short vectors in that
    space. An entry of that list is a triple (v, sign, n). Here v is
    the short vector in standard Leech lattice encoding. The
    components of part 98280_x of axis Y corresponding to the vectors 
    in that space are equal up to sign. Entry 'sign' of a triple is
    the sign of the corresponding component. Entry n is a bit vector
    (i.e. an int) containing  the co-ordinates of v with respect to
    the basis computed above.
    """
    global _SHORT_E8_VECTORS, _E8_BASIS
    if _SHORT_E8_VECTORS is not None:
        return _E8_BASIS, _SHORT_E8_VECTORS
    Cocode([0, 3])
    leech_basis = [XLeech2(0, Cocode([0, x])).ord for x in range(1, 7)]
    leech_basis += [0x800000, XLeech2(PLoop(range(8)), 0).ord]
    _E8_BASIS = leech_basis
    s = [(v, n) for n, v in enumerate(lin_table(leech_basis))
         if gen_leech2_type(v) == 2]
    assert len(s) == 120, len(s)
    _SHORT_E8_VECTORS = [None] * 120
    yd = AXIS_Y.v15.data
    ref = mm_aux_get_mmv_leech2(15, yd, s[0][0])
    ref = ref if 2*ref < 15 else 15 - ref
    signs = [1] * 120
    for i, (v, n) in enumerate(s):
        w = mm_aux_get_mmv_leech2(15, yd, v)
        if w == 15 - ref:
            _SHORT_E8_VECTORS[i] = int(v), -1, n
        else:
            _SHORT_E8_VECTORS[i] = int(v), 1, n
            assert w == ref
    return _E8_BASIS, _SHORT_E8_VECTORS




M8 = None

def inverse_E8():
    """Orthogonal form for vectors computed by short_E8_vectors()

    Let E8_BASIS be the basis of the space of short vectors in the
    Leech lattice mod 2 related to involution Y as computed by
    function short_E8_vectors(). The function returns a quadruple 
    M8, MI8, TYPE2I, TYPE4I.

    M8 is the 8 times 8 bit matrix of the (halved) scalar products of
    the basis vectors given by E8_BASIS. M8I is the inverse of M8.

    For an 8-bit vector b, define TYPE_I(b) as the (unique) vector in
    the space spanned by E8_BASIS as follows:
    The (halved) scalar product of TYPE_I(b) and E8_BASIS[i] is
    equal to b[i] (mod 2).

    Then TYPE2I[b] is TYPE_I(b) is TYPE_I(b) is of type 2 and 0
    otherwise. TYPE4I[b] is TYPE_I(b) is TYPE_I(b) is of type 4
    and 0 otherwise. 
    """
    global M8, MI8, TYPE2I, TYPE4I
    if M8 is not None:
        return M8, MI8
    basis, _ = short_E8_vectors()
    T = [gen_leech2_type(basis[i]) for i in range(8)]
    M8 = [0] * 8
    for i in range(8):
        for j in range(8):
            t_ij = T[i] ^ T[j] ^ gen_leech2_type(basis[i] ^ basis[j])
            M8[i] |=  ((t_ij >> 1) & 1) << j
    MI8 =  bit_mat_inverse(M8)
    return M8, MI8


TYPE4I = None

def type2_4_i():
    """Return set of indices related axis AXIS_Y

    Let E8_BASIS be the basis of the space of short vectors in the
    Leech lattice mod 2 related to involution Y as computed by
    function short_E8_vectors().

    For an 8-bit vector b, define TYPE_I(b) as the (unique) vector in
    the space spanned by E8_BASIS as follows:
    The (halved) scalar product of TYPE_I(b) and E8_BASIS[i] is
    equal to b[i] (mod 2).

    Then TYPE2I[b] is TYPE_I(b) is TYPE_I(b) is of type 2 and 0
    otherwise. TYPE4I[b] is TYPE_I(b) is TYPE_I(b) is of type 4
    and 0 otherwise. 
    """
    global TYPE2I, TYPE4I
    if TYPE4I is not None:
        return  TYPE2I, TYPE4I

    basis, _ = short_E8_vectors()
    T = [gen_leech2_type(basis[i]) for i in range(8)]
    M8 , MI8 = inverse_E8()

    TYPE2I = [0] * 256
    TYPE4I = [0] * 256
    for i in range(256):
        x = bit_mat_mul(i, MI8, _E8_BASIS)
        type_ = gen_leech2_type(x)
        if type_ == 4:
            TYPE4I[i] = x
        if type_ == 2:
            TYPE2I[i] = x
    assert len([x for x in TYPE4I if x]) == 135
    assert len([x for x in TYPE2I if x]) == 120
    return TYPE2I, TYPE4I


    
###### Map centralizer of AXIS_Y in G_x0 into O_8(2)^+ ##########


DICT_LEECH2_E8 = {}
    
def table_leech2_e8():
    """Dictionary mapping the Leech lattice mod 2 to 8-bit vector

    The function returns a dictionary that maps vectors
    0 <= v < 1 << 2**24 in the Leech latice mod 2 to the co-ordinate
    system of the subspace E described in function map_leech2_e8().
    """
    global DICT_LEECH2_E8
    if len(DICT_LEECH2_E8):
        return DICT_LEECH2_E8
    basis, _ = short_E8_vectors()
    for i, v in enumerate(lin_table(basis)):
        assert 0 <= v < 1 << 24, hex(v)
        DICT_LEECH2_E8[v] = i
    return DICT_LEECH2_E8


def map_leech2_e8(v):
    """Map vector in Leech lattice mod 2 to 8-bit vector.

    The centralizer of AXIS_Y in G_x0 fixes a subspace E of the Leech
    lattice mod 2. We define a basis of E. This function maps a
    vector ``v`` given in Leech lattice encoding to a vector in
    the co-ordinates with repect to that basis. It raises an
    exception if this is not possible.    
    """
    d = table_leech2_e8()
    return d[v & 0xffffff]

def map_e8_leech2(i):
    """Map 8 bit vector to vector in Leech lattice mod 2

    This is the inverse of function map_leech2_e8().
    """
    basis, _ = short_E8_vectors()
    return int(bit_mat_mul(i & 0xff, basis))



def map_mm_e8(g):
    """Map element of centralizer of AXIS_Y in G_x0 to 8 x 8 bit matrix

    The centralizer of AXIS_Y in G_x0 fixes a subspace E of the Leech
    lattice mod 2, as described in function map_leech2_e8(v). In that
    function a basis of E is defined. The function returns an 8 times 8
    bit matrix describing the action of g in that basis.
    """
    d = table_leech2_e8()
    gdata = g.mmdata
    basis, _ = short_E8_vectors()
    a = np.array(list(basis), dtype = np.uint32)
    lg = len(gdata)
    assert gen_leech2_op_word_many(a, 8, gdata, lg) == lg
    for i, v in enumerate(a):
        a[i] = d[v & 0xffffff]
    return a  



###### Map vector in G_x0 to Omega, centralizing axis AXIS_Y ##########


MAP_OMEGA = None

def map_omega(v):
    """Map element of Q_x0 to Omega, centralizing axis AXIS_Y

    Given a vector ``v`` in Q_x0 in Leech lattice encoding, the
    function returns an element g of G_x0 that maps ``v`` to
    Omega (up to sign) and centralizes the axis AXIS_Y.
    The function raises an exception if this is not possible.
    Element g is returned as an instance of class Xsp2_Co1.
    """
    global MAP_OMEGA
    if isinstance(v, XLeech2):
        v = v.ord
    if MAP_OMEGA is not None:
        return Xsp2_Co1('a', MAP_OMEGA[v & 0xffffff])
    OMEGA = XLeech2(Xsp2_Co1('x', 0x800))
    a = np.zeros((135, 10), dtype = np.uint32)
    dt = {}
    n = trials = 0
    while len(dt) < 135:
        g = Xsp2_Co1('r')
        i8 = Y_Gx0 ** g
        c, h = i8.conjugate_involution_G_x0()
        #assert c == "2A_o+"
        g1 = g*h
        assert  Y_Gx0 ** g1 == Y_Gx0, ( (Y_Gx0**g1),  Y_Gx0)
        img = (OMEGA * g1).ord & 0xffffff
        if img not in dt:
            mm = (g1**-1).mmdata
            a[n, :len(mm)] = mm
            dt[img] = a[n]
            n += 1
        trials += 1
    #print("MAP_OMEGA:", trials, "trials,", n, "found")
    MAP_OMEGA = dt
    for v1 in MAP_OMEGA:
         prod = XLeech2(v1) * Xsp2_Co1('a', MAP_OMEGA[v1])
         assert (prod.ord & 0xffffff) == 0x800000, hex(prod.ord)
    return Xsp2_Co1('a', MAP_OMEGA[v & 0xffffff])



####### Tables for generated C code ######################################


TYPE4I_BASIS = None

def type_4_i_basis():
    """Return set of indices related axis AXIS_Y

    Let E8_BASIS be the basis of the space of short vectors in the
    Leech lattice mod 2 related to involution Y as computed by
    function short_E8_vectors().

    For an 8-bit vector b, define TYPE_I(b) as the (unique) vector in
    the space spanned by E8_BASIS as follows:
    The (halved) scalar product of TYPE_I(b) and E8_BASIS[i] is
    equal to b[i] (mod 2).

    The function returns a list TYPE4I_BASIS such that TYPE4I_BASIS[i]
    is a bit vector b if TYPE_I(i) is of type 4 and equal to
    b * E8_BASIS. We put TYPE4I_BASIS[i] = if TYPE_I(i) is not of
    type 4. 
    """
    global TYPE4I_BASIS
    if TYPE4I_BASIS is not None:
        return  TYPE4I_BASIS

    basis, _ = short_E8_vectors()
    T = [gen_leech2_type(basis[i]) for i in range(8)]
    M8 , MI8 = inverse_E8()

    TYPE4I_BASIS = [0] * 256
    for i in range(256):
        b = bit_mat_mul(i, MI8)
        x = bit_mat_mul(b, _E8_BASIS)
        type_ = gen_leech2_type(x)
        if type_ == 4:
            TYPE4I_BASIS[i] = b
    assert len([x for x in TYPE4I_BASIS if x]) == 135
    return TYPE4I_BASIS

